function deFun(code) {
	var i = 0;
	var string = "";
	while (code.charAt(i) != "{") {
		string = string + code.charAt(i);
		i++;
	}
	string = string + "{";
	code = code.replace(string, "");
	return code;
}

function visPuzzle(puzzle) {
	var viz = "";

	for (var i = 0; i < puzzle.length; i++) {
		for (var j = 0; j < puzzle.length; j++) {
			viz = viz + "----";
		}
		viz = viz + "-\n";
		for (var j = 0; j < puzzle.length; j++) {
			viz = viz + "| " + puzzle[i][j] + " ";
		}
		viz = viz + "| " + "\n";
	}
	for (var j = 0; j < puzzle.length; j++) {
			viz = viz + "----";
	}
	viz = viz + "-";

	return viz;
}

var chai = require('chai');
var expect = chai.expect;
const assertArrays = require('chai-arrays');
const assertSortedArrays = require('chai-sorted');
chai.use(assertArrays);
chai.use(assertSortedArrays);
var reB = require('../dec/deC.js').reB;
var deC = require('../dec/deC.js').deC;
var deF = require('../dec/deC.js').deF;
var makeRows = require('../../sudoku.js').makeRows;
var permuteRow = require('../../sudoku.js').permuteRow;
var permutePuzzle = require('../../sudoku.js').permutePuzzle;
var checkColumn = require('../../sudoku.js').checkColumn;
var colCheck = require('../../sudoku.js').colCheck;
var checkGrid = require('../../sudoku.js').checkGrid;
var checkGrids = require('../../sudoku.js').checkGrids;
var makeSolution = require('../../sudoku.js').makeSolution;
var genPuzzle = require('../../sudoku.js').genPuzzle;
// --------------------------------------------------------------------------------------------

describe('Task 1 - ', () => {
  // The function should return an array
  var attempted = true;
  it('Has the task been attempted?', () => {
    var mR = require('../add/add.js').makeRows.toString();
    mR = deC(mR);
    mR = reB(mR);
    var check = makeRows.toString();
    check = deC(check);
    check = reB(check);
    var bool = check === mR;
    attempted = bool;
    expect(bool).to.be.false;
  });
	it('Does the function use the argument row?', () => {
    var check = makeRows.toString();
    check = deC(check);
    check = reB(check);
    var bool = check.includes('row');
    expect(bool).to.be.true;
  });
	it('Does the function use a loop?', () => {
    var check = makeRows.toString();
    check = deC(check);
    check = reB(check);
    var bool = check.includes('for(') || check.includes('while(');
    expect(bool).to.be.true;
  });
	it('Does the function return an array of all elements equal to row?', () => {
    var check = makeRows([1,2,3,4]);
    var array = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]];
		expect(check).to.deep.equal(array, '[[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]] should have been returned for the argument [1,2,3,4] -- ');
		check = makeRows([4,2,3,1]);
    array = [[4,2,3,1],[4,2,3,1],[4,2,3,1],[4,2,3,1]];
		expect(check).to.deep.equal(array, '[[4,2,3,1],[4,2,3,1],[4,2,3,1],[4,2,3,1]] should have been returned for the argument [4,3,2,1] -- ');
  });
});

	describe('Task 2 - ', () => {
	  // The function should return an array
	  var attempted = true;
	  it('Has the task been attempted?', () => {
	    var mR = require('../add/add.js').permuteRow.toString();
	    mR = deC(mR);
	    mR = reB(mR);
	    var check = permuteRow.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check === mR;
	    attempted = bool;
	    expect(bool).to.be.false;
	  });
		it('Does the function use the queue data structure?', () => {
			var check = permuteRow.toString();
	    check = deC(check);
	    check = reB(check);
			var bool = check.includes('queue') || check.includes('Queue');
			expect(bool).to.be.true;
	  });
		it('Does the function return an array?', () => {
			var check = permuteRow([1, 2, 3, 4], 1);
			expect(check).to.be.array();
	  });
		it('Does the function return an array of the same length as the argument?', () => {
			var check = permuteRow([1, 2, 3, 4], 1);
			expect(check.length).to.equal(4);
	  });
		it('Does the function return an altered array for p = 1?', () => {
			var array = [1,2,3,4];
			var check = permuteRow(array.slice(), 1);
			var count = 0;
			for (var i = 0; i < 4; i++){
				if (check[i] === array[i]) {
					count++;
				}
			}
			var bool = (count === 4);
			expect(bool).to.be.false;
		});
		it('Does the function return [1, 2, 3, 4] for arguments [1, 2, 3, 4] and p = 0?', () => {
			var array = [1,2,3,4];
	    var check = permuteRow(array, 0);
	    	var array = [1,2,3,4];
			expect(check).to.deep.equal(array);
	  });
		it('Does the function return [1, 2, 3, 4] for arguments [2, 3, 4, 1] and p = 1? \n', () => {
			var array = [1,2,3,4];
	    var check = permuteRow(array, 1);
	    	var array = [2,3,4,1];
			expect(check).to.deep.equal(array);
	  });
	});
/*
	describe('Task 3 - ', () => {
	  // The function should return an array
	  var attempted = true;
	  it('Has the task been attempted?', () => {
	    var mR = require('../add/add.js').permutePuzzle.toString();
	    mR = deC(mR);
	    mR = reB(mR);
	    var check = permutePuzzle.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check === mR;
	    attempted = bool;
	    expect(bool).to.be.false;
	  });
		it('Does the function use the arguments p, q and r?', () => {
	    var check = permutePuzzle.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('p') && check.includes('q') && check.includes('r');
	    expect(bool).to.be.true;
	  });
		it('Does the function call permuteRow?', () => {
	    var check = permutePuzzle.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('permuteRow');
	    expect(bool).to.be.true;
	  });
		it('Does the function return the correct array?', () => {
			var pR = require('../test/add.js').permuteRow;
			var q = require('../test/add.js').queue;
			var original = permutePuzzle.toString();
			original = deFun(original);
			var pR = pR.toString();
			original = "{"+ original;
			original = pR + "\n" + original;
			original = q + "\n" + original;
			var permuteRowNew = new Function("puzzle", "p", "q", "r", original);
			var array = [[4,3,2,1],[4,3,2,1],[4,3,2,1],[4,3,2,1]];
			var check = permuteRowNew([[4,3,2,1],[4,3,2,1],[4,3,2,1],[4,3,2,1]], 1, 3, 2);
			expect(check).to.deep.equal([[4,3,2,1],[3,2,1,4],[1,4,3,2],[2,1,4,3]], '[[4,3,2,1],[3,2,1,4],[1,4,3,2],[2,1,4,3]] should have been returned by permuteRow([[4,3,2,1],[4,3,2,1],[4,3,2,1],[4,3,2,1]], 1, 3, 2) -- ');
	  });
	});
*/
	describe('Task 3 - ', () => {
	  // The function should return an array
	  var attempted = true;
	  it('Has the task been attempted?', () => {
	    var mR = require('../add/add.js').checkColumn.toString();
	    mR = deC(mR);
	    mR = reB(mR);
	    var check = checkColumn.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check === mR;
	    attempted = bool;
	    expect(bool).to.be.false;
	  });
		it('Does the function call linearSearch?', () => {
	    var check = checkColumn.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('linearSearch');
	    expect(bool).to.be.true;
	  });
		it('Does the function use the argument j as a column index?', () => {
	    var check = checkColumn.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('][j]');
	    expect(bool).to.be.true;
	  });
		it('Does the function return true for all columns of [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]?', () => {
			for (var i = 0; i < 4; i++) {
				expect(checkColumn([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]], i)).to.be.true;
			}
	  });
		it('Does the function return false for all columns of [[4, 3, 2, 1], [4, 3, 2, 1], [4, 3, 2, 1], [4, 3, 2, 1]]?', () => {
			for (var i = 0; i < 4; i++) {
				expect(checkColumn([[4, 3, 2, 1], [4, 3, 2, 1], [4, 3, 2, 1], [4, 3, 2, 1]], i)).to.be.false;
			}
	  });
	});

	describe('Task 4 - ', () => {
	  // The function should return an array
	  var attempted = true;
	  it('Has the task been attempted?', () => {
	    var mR = require('../add/add.js').colCheck.toString();
	    mR = deC(mR);
	    mR = reB(mR);
	    var check = colCheck.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check === mR;
	    attempted = bool;
	    expect(bool).to.be.false;
	  });
		it('Does the function call checkColumn?', () => {
	    var check = colCheck.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('checkColumn');
	    expect(bool).to.be.true;
	  });
		it('Can the function return a Boolean?', () => {
	    var check = colCheck([[1, 2, 3, 4],[1, 2, 3, 4],[1, 2, 3, 4],[1, 2, 3, 4]]);
			var check2 = colCheck([[1, 2, 3, 4], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]]);
			var check3 = colCheck([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]);
			var bool = (typeof check === 'boolean') || (typeof check2 === 'boolean') || (typeof check3 === 'boolean');
	    expect(bool).to.equal(true, 'Several arguments have been given to the function and none of them return a Boolean -- ');
	  });
		it('Does the function return correct thing?', () => {
			var cC = require('../test/add.js').checkColumn;
			var lS = require('../test/add.js').linearSearch;
			var original = colCheck.toString();
			original = deFun(original);
			original = "{"+ original;
			original = cC + "\n" + original;
			original = lS + "\n" + original;
			var colCheckNew = new Function("puzzle", original);
			expect(colCheckNew([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]])).to.equal(true, 'For argument [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]], true should have been returned -- ');
			expect(colCheckNew([[1, 2, 3, 4], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]])).to.equal(true, 'For argument [[1, 2, 3, 4], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]], true should have been returned -- ');
			expect(colCheckNew([[1, 2, 3, 2], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]])).to.equal(false, 'For argument [[1, 2, 3, 2], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]], false should have been returned -- ');
	  });
	});

	describe('Task 5 - ', () => {
		// The function should return an array
		var attempted = true;
		it('Has the task been attempted?', () => {
			var mR = require('../add/add.js').checkGrid.toString();
			mR = deC(mR);
			mR = reB(mR);
			var check = checkGrid.toString();
			check = deC(check);
			check = reB(check);
			var bool = check === mR;
			attempted = bool;
			expect(bool).to.be.false;
		});
		it('Does the function call makeGrid?', () => {
	    var check = checkGrid.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('makeGrid');
	    expect(bool).to.be.true;
	  });
		it('Does the function call linearSearch?', () => {
	    var check = checkGrid.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('linearSearch');
	    expect(bool).to.be.true;
	  });
		it('Does the function use the arguments row1, row2, col1, col2?', () => {
	    var check = checkGrid.toString();
	    check = deC(check);
	    check = reB(check);
	    var bool = check.includes('row1') && check.includes('row2') && check.includes('col1') && check.includes('col2');
	    expect(bool).to.be.true;
	  });
		it('Does the function return correct thing? \n', () => {
			var cC = require('../test/add.js').makeGrid;
			var lS = require('../test/add.js').linearSearch;
			var original = checkGrid.toString();
			original = deFun(original);
			original = "{"+ original;
			original = cC + "\n" + original;
			original = lS + "\n" + original;
			var checkGridNew = new Function("puzzle", "row1", "row2", "col1", "col2", original);
			expect(checkGridNew([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]], 0,1,0,1)).to.equal(false, 'checkGrid([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]], 0,1,0,1) should have returned false -- ');
			expect(checkGridNew([[1, 2, 3, 4], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]], 0,1,0,1)).to.equal(true, 'checkGrid([[1, 2, 3, 4], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]], 0,1,0,1) should have returned true -- ');
			expect(checkGridNew([[1, 2, 3, 2], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]],2,3,0,1)).to.equal(true, 'checkGrid([[1, 2, 3, 2], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3]], 2,3,0,1) should have returned true -- ');
	  });
	});

