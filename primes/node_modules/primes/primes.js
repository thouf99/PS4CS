function stringCompare(string, text, startingIndex) {
  var n = string.length;
  if (startingIndex + n - 1 > text.length) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    // compare characters in a string here
    if (text.charAt(startingIndex + i) !== string.charAt(i)) {
      return false;
    }
  }
  return true;
}

function searchString(string, text) {
  var n = string.length;
  var t = text.length;
  if (t < n) {
    return false;
  }
  // search text for the first character in string
  var count = 0;
  for (var i = 0; i < t; i++) {
    if (text.charAt(i) === string.charAt(0)) {
      if (stringCompare(string, text, i)){
        count++;
      }
    }
  }
  return count;
}function stringCompare(string, text, startingIndex) {
  var n = string.length;
  if (startingIndex + n - 1 > text.length) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    // compare characters in a string here
    if (text.charAt(startingIndex + i) !== string.charAt(i)) {
      return false;
    }
  }
  return true;
}

function searchString(string, text) {
  var n = string.length;
  var t = text.length;
  if (t < n) {
    return false;
  }
  // search text for the first character in string
  var count = 0;
  for (var i = 0; i < t; i++) {
    if (text.charAt(i) === string.charAt(0)) {
      if (stringCompare(string, text, i)){
        count++;
      }
    }
  }
  return count;
}

function findNext(string, startingIndex) {
	for (var i = startingIndex; i < string.length; i++) {
		if ((string.charAt(i) === "}") || (string.charAt(i) === "{")){
			return i;
		}
	}
	return false;
}

function Stack() {
	this.arr = [];
	this.push = function(element) {
		this.arr.push(element);
	};
	this.peek = function() {
		return this.arr[this.arr.length-1];
	};
	this.pop = function() {
		if (this.arr.length == 0) {
			return "Stack underflow!";
		} else {
			return this.arr.pop();
		}
	};
	this.isEmpty = function() {
			return this.arr.length == 0;
	};
}

function closingBracket(code, startingIndex) {
	var stack = new Stack();
	var i = startingIndex + 1;
	while (code.charAt(i) !== "") {
		//console.log(code.charAt(i));
		if (code.charAt(i) === "{") {
			stack.push(code.charAt(i));
		} else if (code.charAt(i) === "}") {
			if (stack.peek() !== "{") {
				return i;
			} else {
				stack.pop();
			}
		}
		i++;
	}
	return false;
}

function containsBinarySearch(string) {
  var re1 = /while\(.+\)/;
  var re2 = /while\(.+\)/;
  var re3 = /while\(.+\)/;
  var re4 = /while\(.+\)/;
  var index1 = string.search(re1);
  var index2 = string.search(re2);
  var index3 = string.search(re3);
  var index4 = string.search(re4);
  var index = -1;
  if (index1 !== -1) {
    index = index1;
  } else if (index2 !== -1) {
    index = index2;
  } else if (index3 !== -1) {
    index = index3;
  } else if (index4 !== -1) {
    index = index4;
  }
  if (index === -1) {
    return false;
  }
  var start = findNext(string, index);
  var end = closingBracket(string, start);
  if (end === false) {
    return false;
  }
  var str = string.slice(index, end + 1);
	//console.log(str);
  return (searchString("if(", str) >= 2);
}


var chai = require('chai');
var expect = chai.expect;
const assertArrays = require('chai-arrays');
const assertSortedArrays = require('chai-sorted');
chai.use(assertArrays);
chai.use(assertSortedArrays);
var reB = require('../dec/deC.js').reB;
var deC = require('../dec/deC.js').deC;
var deF = require('../dec/deC.js').deF;
var minBinarySearch = require('../../primes.js').minBinarySearch;
var genPrimes = require('../../primes.js').genPrimes;
var randomPrime = require('../../primes.js').randomPrime;
var semiPrimes = require('../../primes.js').semiPrimes;

// --------------------------------------------------------------------------------------------

// Testing the first task------------------------
describe('#Task 1: ', () => {
  // The function should return an array
  var attempted = true;
  it('Task attempted', () => {
    // get mBS from add.js in auxiliary
    var mBS = require('../add/add.js').mBS.toString();
    mBS = deC(mBS);
    mBS = reB(mBS);
    var check = minBinarySearch.toString();
    check = deC(check);
    check = reB(check);
    var bool = check === mBS;
    attempted = bool;
    expect(bool).to.be.false;
  });

  it('MISSING1 does not appear in attempted code', () => {
    // search for MISSING1
    var check = minBinarySearch.toString();
    check = deC(check);
    check = reB(check);
    let bool = check.includes("MISSING1");
    if (attempted) {
      bool = true;
    }
    expect(bool).to.be.false;
	});

	it('MISSING2 does not appear in attempted code', () => {
    // search for MISSING2
    var check = minBinarySearch.toString();
    check = deC(check);
    check = reB(check);
    let bool = check.includes("MISSING2");
    if (attempted) {
      bool = true;
    }
    expect(bool).to.be.false;
	});

	it('MISSING3 does not appear in attempted code', () => {
    // search for MISSING3
    var check = minBinarySearch.toString();
    check = deC(check);
    check = reB(check);
    let bool = check.includes("MISSING3");
    if (attempted) {
      bool = true;
    }
    expect(bool).to.be.false;
	});

  it('minBinarySearch returns correct output', () => {
    // search for MISSING3
    var array = [0, 1, 2, 3, 4];
    var check = minBinarySearch(array, 1);
    expect(check).to.equal(2);
    check = minBinarySearch(array, 3);
    expect(check).to.equal(4);
    array = [5, 6, 7, 8];
    check = minBinarySearch(array, 2);
    expect(check).to.equal(0);
	});
  });

  // Testing the second task------------------------
  describe('#Task 2: ', () => {
    // The function should return an array
    it('Task attempted', () => {
      // get mBS from add.js in auxiliary
      var gP = require('../add/add.js').gP.toString();
      gP = deC(gP);
      gP = reB(gP);
      var check = genPrimes.toString();
      check = deC(check);
      check = reB(check);
      var bool = check === gP;
      expect(bool).to.be.false;
    });

    it('Only two new loops created', () => {
      // get mBS from add.js in auxiliary
      var check = genPrimes.toString();
      check = deC(check);
      check = reB(check);
      var count = searchString("while(", check);
      var bool1 = (count === 2);
      var bool2 = (count === 1);
      count = searchString("for(", check);
      var bool3 = (count === 4);
      var bool4 = (count === 3);

      var bool = (bool1 && !bool3) || (!bool1 && bool3);
      var bool5 = bool2 && bool4;

      bool = (bool && !bool5) || (!bool && bool5)
      expect(bool).to.be.true;
    });

    it('genPrimes returns correct output', () => {
      // search for MISSING3
      var array = genPrimes(3);
      expect(array).to.deep.equal([2, 3], 'genPrimes(3) should have returned [2, 3]');
      var array = genPrimes(9);
      expect(array).to.deep.equal([2, 3, 5, 7], 'genPrimes(9) should have returned [2, 3, 5, 7]');
      var array = genPrimes(15);
      expect(array).to.deep.equal([2, 3, 5, 7, 11, 13], 'genPrimes(15) should have returned [2, 3, 5, 7, 11, 13]');
  	});
});

// Testing the third task------------------------
describe('#Task 3: ', () => {
  // The function should return an array
  it('Task attempted', () => {
    // get mBS from add.js in auxiliary
    var rP = require('../add/add.js').rP.toString();
    rP = deC(rP);
    rP = reB(rP);
    var check = randomPrime.toString();
    check = deC(check);
    check = reB(check);
    var bool = check === rP;
    expect(bool).to.be.false;
  });
  //check that the function calls both genPrimes and minBinarySearch
  it('Function calls genPrimes, minBinarySearch and Math.random()', () => {
    // get mBS from add.js in auxiliary
    var check = randomPrime.toString();
    check = deC(check);
    check = reB(check);
    var bool = check.includes('minBinarySearch');
    var bool2 = check.includes('genPrimes');
    var bool3 = check.includes('Math.random(');
    expect(bool && bool2 && bool3).to.be.true;
  });
  //check that the function calls both genPrimes and minBinarySearch
  it('Function returns a prime of length len', () => {
    // get mBS from add.js in auxiliary
    function deFun(code) {
    	var i = 0;
    	var string = "";
    	while (code.charAt(i) != "{") {
    		string = string + code.charAt(i);
    		i++;
    	}
    	string = string + "{";
    	code = code.replace(string, "");
    	return code;
    }
    var minBS = require('../test/add.js').minBS;
    var genP = require('../test/add.js').genP;
    var original = randomPrime.toString();
    original = deFun(original);
    var genP = genP.toString();
    var mBS = minBS.toString();
    original = "{"+ original;
    original = mBS + "\n" + original;
    original = genP + "\n" + original;
    var randomPrimeNew = new Function("len", original);
    var check1 = randomPrimeNew(1);
    //console.log(check1);
    var bool1 = (check1 === 2) || (check1 === 3) || (check1 === 5) || (check1 === 7);
    var primes = [11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97];
    var primes3 = [101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    check1 = randomPrimeNew(2);
    //console.log(check1);
    var bool2 = primes.includes(check1);
    var check2 = randomPrimeNew(3);
    //console.log(check2);
    var bool3 = primes3.includes(check2);
    var check3 = randomPrimeNew(2);
    var bool4 = primes.includes(check3);
    var check4 = randomPrimeNew(3);
    var bool5 = primes3.includes(check4);
    var everything = bool1 && bool2 && bool3 && bool4 && bool5;
    expect(everything).to.be.true;
  });
});