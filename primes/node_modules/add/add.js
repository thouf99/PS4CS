function minBinarySearch(array, item) {
	var l = 0;
	var r = array.length - 1;
	if (r == 0) {
		return false;
	}
	// complete the following code, which has been commented out (and uncomment it)
	// put in something for MISSING1, MISSING2 and MISSING3
	/*
	while (r >= l) {
		var m = Math.floor((l + r) / 2);
		if (MISSING1) {
			return MISSING2;
		} else if (MISSING3) {
			l = m + 1;
		} else {
			r = m - 1;
		}
	}
	*/
	return l;
}

function genPrimes(n) {
	// this generates an array storing two-element arrays: each element stores an integer i and the Boolean true
	var array = [];
	for (var i = 2; i <= n; i++) {
		array.push([i,true]);
	}
	// complete the code here to implement the Sieve of Eratosthenes
	// if the value stored in array is not prime then the associated Boolean should be changed to false

	// this will loop over all elements in array and if the Boolean in each element is true, then it pushes that number to out
	// out will store all primes up to (and possibly including) n
	var out = [];
	for (var i = 0; i < array.length; i++){
		if (array[i][1]) {
			out.push(array[i][0]);
		}
	}
	return out;
}

function randomPrime(len) {
	//complete the code to return a random prime number of length len, i.e. with len digits

	//this makes an array storing all the prime numbers with at most len digits
	var primes = genPrimes(10**(len)-1);
	
	//remember that the smallest number with len digits is 10**(len-1), and the largest number of length len is 10**(len)-1
}

function semiPrimes(n) {
	//complete this function
}

module.exports = {mBS : minBinarySearch, gP : genPrimes, rP : randomPrime, sP : semiPrimes}
