/* eslint-env mocha */
'use strict';

function Queue() {
  this.arr = [];
  this.head = function() {
    return this.arr[0];
  };
  this.dequeue = function() {
    if (this.arr.length == 0) {
      return "Queue underflow!";
    } else {
      return this.arr.shift();
    }
  };
  this.enqueue = function(o) {
    this.arr.push(o);
  };
  this.isEmpty = function() {
      return this.arr.length == 0;
  };
}

function visQueue(queue) {
  var str = "head --> ";
  if (queue.isEmpty()) {
    return "empty";
  }
  var extra = new Queue;
  while (!(queue.isEmpty())) {
    str = str + queue.head() + " ";
    extra.enqueue(queue.head());
    queue.dequeue();
  }
  str = str + "<-- tail"
  while (!(extra.isEmpty())) {
    queue.enqueue(extra.head());
    extra.dequeue();
  }
  return str;
}

var chai = require('chai');
var expect = chai.expect;
const assertArrays = require('chai-arrays');
const assertSortedArrays = require('chai-sorted');
chai.use(assertArrays);
chai.use(assertSortedArrays);
var reB = require('../dec/deC.js').reB;
var deC = require('../dec/deC.js').deC;
var lab = require('../../lab3.js');

describe('Test arrToQueue -', () => {
  it('arrToQueue should return a queue', () => {
    let arr = [1,2,3];
    let t = lab.arrToQueue(arr);
    let s = typeof t.isEmpty();
    expect(t.arr).to.be.array();
    expect(s).to.equal("boolean");
  });
  let queue = new Queue();
  queue.enqueue(3);
  queue.enqueue(2);
  queue.enqueue(1);
  it('For the argument [3, 2, 1] the queue should be:\n' + visQueue(queue) + '\n' , () => {
    let arr = [3,2,1];
    let t = lab.arrToQueue(arr);
    expect(t.arr).to.be.equalTo(arr);
  });
  it('arrToQueue should call the method queue.enqueue', () => {
    let t = lab.arrToQueue.toString();
    t = reB(deC(t));
    let s = t.includes("queue.enqueue(");
    expect(s).to.be.true;
  });
});
describe('Test permuteQueue -', () => {
  let queue = new Queue();
  queue.enqueue(1);
  queue.enqueue(2);
  queue.enqueue(3);
  queue.enqueue(4);
  it('permuteQueue should return a queue', () => {
    let t = lab.permuteQueue(queue,1);
    let s = typeof t.isEmpty();
    expect(t.arr).to.be.array();
    expect(s).to.equal("boolean");
  });
  it('For the argument queue being ' + visQueue(queue) + ',\npermuteQueue(queue,0) should return ' + visQueue(queue) + '\n' , () => {
    queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    let arr = [1,2,3,4];
    let t = lab.permuteQueue(queue, 0);
    expect(t.arr).to.be.equalTo(arr);
  });
  let queue1 = new Queue();
  queue1.enqueue(3);
  queue1.enqueue(4);
  queue1.enqueue(1);
  queue1.enqueue(2);
  it('For the argument queue being ' + visQueue(queue) + ',\npermuteQueue(queue,2) should return ' + visQueue(queue1) + '\n' , () => {
    queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    let arr = [3,4,1,2];
    let t = lab.permuteQueue(queue, 2);
    expect(t.arr).to.be.equalTo(arr);
  });
  it('permuteQueue should call the method queue.dequeue', () => {
    let t = lab.permuteQueue.toString();
    t = reB(deC(t));
    let s = t.includes("queue.dequeue(");
    expect(s).to.be.true;
  });
  it('permuteQueue should call the method queue.enqueue', () => {
    let t = lab.permuteQueue.toString();
    t = reB(deC(t));
    let s = t.includes("queue.enqueue(");
    expect(s).to.be.true;
  });
});
describe('Test queueToArr -', () => {
  let queue = new Queue();
  queue.enqueue(1);
  queue.enqueue(2);
  queue.enqueue(3);
  queue.enqueue(4);
  it('queueToArr should return an array', () => {
    let t = lab.queueToArr(queue);
    expect(t).to.be.array();
  });
  it('For the argument queue being ' + visQueue(queue) + ',\nqueueToArr(queue) should return [1, 2, 3, 4]' , () => {
    queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    queue.enqueue(4);
    let arr = [1,2,3,4];
    let t = lab.queueToArr(queue);
    expect(t).to.be.equalTo(arr);
  });
  it('arrToQueue should call the method queue.dequeue', () => {
    let t = lab.queueToArr.toString();
    t = reB(deC(t));
    let s = t.includes("queue.dequeue(");
    expect(s).to.be.true;
  });
});
describe('Test encryptMessage -', () => {
  it('encryptMessage("hello", 4) should return "lipps"', () => {
    let t = lab.encryptMessage("hello", 4);
    expect(t).to.equal("lipps");
  });
  it('encryptMessage should call encrypt function', () => {
    let t = lab.encryptMessage.toString();
    t = reB(deC(t));
    let s = t.includes("encrypt(");
    expect(s).to.be.true;
  });
});
